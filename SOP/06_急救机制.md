# 紫微智控 - 急救机制规范

## 机制概述

**急救员** (The Paramedic) 负责监控系统健康，检测卡死并触发自愈流程。

| 项目 | 规格 |
|------|------|
| **心跳检测** | 每 30 秒检查一次 |
| **卡死判定** | 心跳文件 >2 分钟未更新 |
| **会诊模型** | bailian/qwen3.5-plus（云端） |
| **重启策略** | 云端方案优先，重启为最后手段 |
| **恢复保证** | 断点续跑，避开错误路线 |

---

## 核心原则

> **云脑本地身**：本地只负责心跳监控，诊断和决策全部外包给云端

| 原则 | 说明 |
|------|------|
| **轻量监控** | 本地仅运行一个脚本，内存占用 <10MB |
| **异步诊断** | 卡死后调用云端模型分析，本地不复杂计算 |
| **状态持久** | 所有状态保存在文件系统，重启不丢进度 |
| **透明通知** | 卡死→重启→恢复，全程邮件通知康纳 |

---

## 心跳监控机制

### 心跳文件

**路径**: `data/health/heartbeat.log`

### 更新机制
- **更新者**: 记录官（或各岗位在完成动作时）
- **更新频率**: 每次岗位动作后追加一行
- **格式**:
```
[2025-02-27T14:00:00+08:00] T-01 任务分解完成
[2025-02-27T14:05:00+08:00] T-02 代码生成开始
[2025-02-27T14:18:00+08:00] T-04 巡查完成（正常）
[2025-02-27T14:36:00+08:00] T-04 巡查完成（正常）
```

### 检查逻辑

**脚本**: `scripts/paramedic.py`

```python
#!/usr/bin/env python3
# 急救员监控脚本

import os
import time
from datetime import datetime, timedelta

HEARTBEAT_FILE = "data/health/heartbeat.log"
EMERGENCY_FLAG = "data/health/emergency.flag"
RECOVERY_PLAN = "data/health/recovery_plan.txt"

def check_heartbeat():
    """检查心跳文件"""
    if not os.path.exists(HEARTBEAT_FILE):
        return False, "心跳文件不存在"
    
    mtime = datetime.fromtimestamp(os.path.getmtime(HEARTBEAT_FILE))
    elapsed = datetime.now() - mtime
    
    if elapsed > timedelta(minutes=2):
        return False, f"心跳超时 {elapsed.seconds // 60} 分钟"
    
    return True, "正常"

def main():
    while True:
        healthy, message = check_heartbeat()
        
        if not healthy:
            print(f"[警报] {message}")
            trigger_emergency(message)
        else:
            print(f"[正常] {message}")
        
        time.sleep(30)  # 每 30 秒检查一次
```

---

## 应急响应流程

### 触发条件

| 条件 | 阈值 | 响应 |
|------|------|------|
| 心跳超时 | >2 分钟 | 判定卡死 |
| 任务文件未更新 | >2 小时 | 高度疑似卡死 |
| 内存占用 | >95% | 紧急预警 |
| CPU 持续满载 | >30 分钟 | 紧急预警 |

### 响应流程

```
┌─────────────────────────────────────────────────────────┐
│                    应急响应流程                          │
└─────────────────────────────────────────────────────────┘

1. 急救员检测到心跳超时
       ↓
2. 生成 emergency.flag（锁定现场）
       ↓
3. 收集日志快照（heartbeat.log, 最近任务文件）
       ↓
4. 调用云端模型（bailian/qwen3.5-plus）会诊
       ↓
5. 接收云端修复方案（JSON 格式）
       ↓
6. 判断是否需要重启
       ↓
   ┌─────┴─────┐
   ↓           ↓
无需重启    需要重启
   ↓           ↓
执行方案   发送警报邮件
   ↓           ↓
继续运行   执行重启
           ↓
       重启后恢复
```

---

## 云端会诊 Prompt

### 系统提示词

```
你是紫微智控的首席技术官，正在参与一场紧急会诊。

我们的急救员系统检测到本地调度主机可能已因任务阻塞而卡死。

你的任务是基于提供的日志快照，进行远程诊断，并给出具体的、可操作的恢复指令。

请注意：
- 执行端（本地主机）资源极其有限（2G 内存），只能执行简单的文件操作或指令修改
- 严禁建议本地复杂计算或人工干预
- 输出必须是 JSON 格式，便于脚本解析执行

请严格按照以下步骤分析：
1. 诊断病因（死循环/资源阻塞/逻辑死锁/数据异常）
2. 开具处方（终止任务/跳过步骤/调整参数/切换备用）
3. 输出 JSON 格式的诊断结果和指令
```

### 输出格式

```json
{
  "diagnosis": "检测到代码生成任务陷入无限循环",
  "instruction": "删除 /home/admin/Ziwei/data/tasks/current/task_in_progress.md 文件以终止当前任务",
  "recovery_node": "从上一个成功步骤重新开始，或直接进入质检环节",
  "requires_reboot": false
}
```

---

## 三封邮件通知

### 第 1 封：卡死警报

**触发**: 急救员检测到卡死，生成 emergency.flag

```markdown
---
主题：🚨【紧急警报】紫微智控系统疑似卡死，正在尝试自动修复
收件人：康纳 <19922307306@189.cn>
抄送：Martin <pandac00@163.com>
---

康纳：

紫微智控系统于 [时间戳] 检测到**心跳超时**，疑似卡死。

## 事件信息
- **检测时间**: [YYYY-MM-DD HH:MM:SS]
- **心跳超时**: [X 分钟]
- **当前任务**: [任务 ID/名称]
- **最后日志**: [最后一条心跳记录]

## 已采取措施
1. 已生成 emergency.flag（锁定现场）
2. 已收集日志快照
3. 已调用云端模型会诊
4. 正在等待修复方案

## 下一步
- 如无需重启：系统将自动执行修复方案，继续运行
- 如需重启：将发送第二封邮件通知，然后执行重启

系统正在尝试自动修复，请稍后查看恢复报告。

---
紫微智控 急救员
```

### 第 2 封：重启通知

**触发**: 云端方案建议重启

```markdown
---
主题：⚠️【紧急通知】系统即将执行重启以恢复任务
收件人：康纳 <19922307306@189.cn>
抄送：Martin <pandac00@163.com>
---

康纳：

云端会诊结果显示**需要重启**才能恢复系统。

## 诊断结果
- **卡死原因**: [云端诊断结果]
- **修复方案**: [简述方案]
- **为何重启**: [解释原因]

## 重启计划
- **执行时间**: 立即
- **预计耗时**: 2-5 分钟
- **恢复策略**: 从 [断点位置] 继续执行
- **风险规避**: 跳过导致卡死的 [步骤 X]

## 数据安全
- 所有任务文件已保存
- 断点信息已记录
- 重启后可完全恢复

系统将在 1 分钟后执行重启。重启完成后将发送恢复报告。

---
紫微智控 急救员
```

### 第 3 封：恢复报告

**触发**: 系统重启完成，任务恢复运行

```markdown
---
主题：✅【系统恢复】任务已从卡死状态中恢复
收件人：康纳 <19922307306@189.cn>
抄送：Martin <pandac00@163.com>
---

康纳：

紫微智控系统已**成功恢复**运行。

## 事件回顾
- **卡死时间**: [YYYY-MM-DD HH:MM:SS]
- **恢复时间**: [YYYY-MM-DD HH:MM:SS]
- **总耗时**: [X 分钟]

## 卡死原因
[云端诊断摘要，例如：代码特种兵生成的脚本陷入死循环]

## 处理措施
1. [已执行的操作 1]
2. [已执行的操作 2]
3. [已执行的操作 3]

## 恢复状态
- **当前任务**: [任务 ID/名称]
- **恢复位置**: [从哪个节点继续]
- **跳过步骤**: [如有，说明跳过的错误步骤]
- **系统状态**: 正常运行

## 后续计划
系统正在继续处理原任务，预计 [时间] 完成。

---
紫微智控 急救员
```

---

## 重启恢复脚本

### 开机自启动脚本

**文件**: `scripts/startup.sh`

```bash
#!/bin/bash
# 紫微智控开机自启动脚本

HEALTH_DIR="/home/admin/Ziwei/data/health"
EMERGENCY_FLAG="$HEALTH_DIR/emergency.flag"
RECOVERY_PLAN="$HEALTH_DIR/recovery_plan.txt"

# 检查是否存在 emergency.flag
if [ -f "$EMERGENCY_FLAG" ]; then
    echo "[急救重启] 检测到 emergency.flag，执行恢复流程"
    
    # 读取恢复计划
    if [ -f "$RECOVERY_PLAN" ]; then
        echo "[恢复计划] $(cat $RECOVERY_PLAN)"
        
        # 执行恢复操作
        # 1. 清理卡死文件
        # 2. 恢复断点
        # 3. 跳过错误步骤
        # 4. 继续任务
        
        # 删除 flag
        rm "$EMERGENCY_FLAG"
        echo "[完成] 恢复流程执行完毕"
    else
        echo "[错误] recovery_plan.txt 不存在，等待人工介入"
    fi
else
    echo "[正常启动] 无急救 flag，正常启动系统"
fi

# 启动主监控脚本
python3 /home/admin/Ziwei/scripts/local_monitor.py
```

---

## 断点续跑机制

### 断点文件格式

**文件**: `data/tasks/[任务 ID]_breakpoint.json`

```json
{
  "task_id": "TASK-20250227-001",
  "last_successful_step": "code_generation",
  "current_step": "code_audit",
  "step_status": {
    "task_received": "completed",
    "task_decomposed": "completed",
    "code_generation": "completed",
    "code_audit": "interrupted",
    "delivery": "pending",
    "archive": "pending"
  },
  "skip_steps": [],
  "modified_params": {},
  "timestamp": "2025-02-27T14:36:00+08:00"
}
```

### 恢复逻辑

1. **读取断点**: 开机后读取 breakpoint.json
2. **检查 skip_steps**: 跳过标记的步骤
3. **恢复状态**: 从 last_successful_step 的下一步继续
4. **应用参数**: 使用 modified_params 中的修改后参数

---

## 健康监控面板

### 监控指标

| 指标 | 正常范围 | 预警阈值 | 紧急阈值 |
|------|---------|---------|---------|
| 心跳间隔 | <1 分钟 | 1-2 分钟 | >2 分钟 |
| 内存占用 | <70% | 70-90% | >90% |
| CPU 占用 | <50% | 50-80% | >80% |
| 磁盘空间 | >20% | 10-20% | <10% |
| 任务队列 | <5 个 | 5-10 个 | >10 个 |

### 可视化（Obsidian）

在 Obsidian 中创建 Dashboard 笔记，通过 Dataview 插件显示：

```markdown
## 系统健康状态
```dataview
TABLE status, last_update, cpu, memory
FROM "data/health"
WHERE type = "metric"
SORT last_update DESC
LIMIT 1
```
```

---

**版本**: 1.0  
**最后更新**: 2025-02-27  
**状态**: 生效中
